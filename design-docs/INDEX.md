# design-docs

## 全体図

(To Be Documented: わかりやすく図解した画像ファイル)

## リモートサーバーから投稿が入ってきたとき

1. ブリッジサーバーからローカルサーバーあてにアクティビティペイロードが入ってくる
2. スパムフィルターを通す
3. 署名を検証する
4. ローカルサーバーに転送する
5. リモートアクターをGetOrFetchする
6. 当該アクティビティをDapeのエンティティに翻訳する
7. データベース層に書き込みを行う

Cf Queueなどを活用してバッチ処理を行う予定 - 後でちゃんと書く

## ストリームスライス

### ストリームスライスの定義

ここでいうストリームスライスとは、

1. 閲覧者がフォローしているユーザーの投稿
2. ユーザーリストに入れられているユーザーの投稿
3. (Misskey で言うところの) アンテナにマッチしたユーザーの投稿

を、それぞれ作成日時が新しい順から古い順に並べた連続部分列を指す。

要するに、各種SNSで「タイムライン」と言われて思い浮かべるものとおおよそ合致する。

ただし、Twitterや9ineverse、はなみすきーに存在するレコメンデーションベースの投稿アピアランスは慣例的に「タイムライン」と呼ばれているもののこの定義には含まれない。

そのようなレコメンデーションベースの投稿アピアランスは、ソートの順位が時系列にとどまらず異なった指標を用いて算出されるため、このセクションでは扱わない。

### 構築するとき

Redis の SortedSet を活用して Fanout-timeline を構築する

Fanout-timeline: https://www.infoq.com/presentations/Twitter-Timeline-Scalability/

ログインユーザー1人につき、最新N件を持っておく (N <= 3000)

### データベースにフォールバックすることによって生まれるパフォーマンスのデグレを防ぐために意図的に導入する非正規化構造
#### タイムラインを構築するときの補助ノード
実際にデータベースにフォールバックが発生してもいいように、デイリーで投稿したユーザーを関連付けるノードを新しく作成する。例えば、`(d:DailyPost { date: "2024-05-01+0900" }) -[:CONTAINS] -> (u:User { id: "uid_example" })` というようなリレーションを挿入する。

#### lastPostedAt
これを持たせることで全ユーザー操作ではなく、インデックスを生かした操作になることが期待できる。また、統計的に最近ノートしたユーザーについてはよくノートするので、そういう状況も考えると有効な最適化だと思われる。

