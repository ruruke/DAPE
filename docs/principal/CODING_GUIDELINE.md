# コーディングガイドライン

DAPEにおけるコーディングガイドラインを定めます。

## 原則

### 日本語を用いる

DAPE のコアメンバーは日本語ネイティブのため、各種コミュニケーション・記述にあたっては日本語を用いることとします。

### Scala の標準的なコーディングスタイルをベースとして用いる

[Scala Style Guide](https://docs.scala-lang.org/style/)
をベースとして用います。また、scalafmt を用いてコードフォーマットを統一します。

### 車輪の再発明をしない

我々は暇ではないため、車輪の再発明をするべきではありません。

例えば、非中央集権的なマイクロサービス群において、事実上重複しない識別子をマイクロサービス間でコミュニケーションすることなく採番したい場合を考えます。
この時、目的に合致する UUIDv4 などの世の中ですでに広く受け入れられているアプローチを取るべきです。

また、すでに存在するライブラリの使用を検討することなく DAPE で実装することもあってはなりません。
使用を検討し、ライセンスや目的が合致しない場合、かつフォークや修正も不可能な場合に限って DAPE で実装することを検討してください。

さらに、すでに標準ライブラリに存在する場合はサードパーティーに存在するライブラリよりも優先して使用します。

### ドキュメントよりも命名、命名よりもシグネチャ

メソッドやプロパティ、フィールドなどに書かれるドキュメントは往々にしてコードベースとの同期が遅れ、腐りやすいです。

そのため、ドキュメントに書く前に命名に反映できないか検討してください。また、命名に反映する前に、戻り値型、引数の型、属性によって表現できないか検討してください。

以下は、検討にあたって優先するべき順位で並べた指針です。

1. 引数の型・戻り値の型
2. 属性
3. 命名
4. コードと同じファイルに埋め込まれるドキュメント
5. コードと異なるファイルに置かれるドキュメント

## Git

### master に直pushしない

master に直接pushするのは以下の理由で大変危険です。

1. CI・CDの結果が後手になる
2. バグがあった場合、壊れた状態をベースにすることになる

### feature branch を作成する

上の話と関係しますが、新規機能追加・バグ修正・リファクタリングなどあらゆる変更を積むためにはまず feature branch を作成してください。

(※便宜的に *feature branch* と名前をつけていますが、 *feature* 以外でも *feature branch* を作成してください。

その際、ブランチの名前に以下の名前をつけないでください。

* `master`
* `main`
* `trunk`
* `develop`
* `live`
* `gh-pages`

### コミットの粒度

バグの bisect が簡単になるように、ローカルのブランチでは細かい単位でコミットすることを推奨します。

また、後述の Conventional Commits におけるプレフィクスが混合しない粒度に切り分けてください。
### コミットメッセージ

1. 何をしたか後で見返してわかるようなメッセージにしましょう。
2. [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) を採用します。

### Conventional Commits のプレフィクス

DAPE のコミットメッセージでは、一貫性のためにプレフィクスへ以下の定義を与えることにします。

*  `build`: ビルド構成を追加・変更したとき・ライブラリのバージョンを変えたとき・ライブラリを導入したとき
*  `chore`: 雑用
*  `ci`: 継続的インテグレーション
*  `docs`: ドキュメンテーション
*  `feat`: 機能追加
*  `fix`: バグ修正
*  `perf`: パフォーマンス改善
*  `refactor`: リファクタリング
*  `style`: コードのスタイルを修正したとき
*  `test`: テストを追加・変更・削除したとき

参考: https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#type

TODO: Renovate の挙動を揃える

## GitHub

### Pull Request を作成する

これも上の話と関係しますが、常に Pull Requst を作成してください。

### CI が通っていない Pull Request をマージしない

DAPE では品質担保の手段として継続的インテグレーション (CI) を採用しています。

CI が通っていないということは、システムのトラブルを除けばその変更が何らかの理由で受け入れ不可能ということです。

問題点を修正する前に CI が通っていない Pull Request をマージしないようにしてください。

## 命名

### Scala の予約語と同じ識別子は避ける

Scala の予約語と同じ識別子は避けてください。バッククォートによるエスケープを用いても同様です。

理由: バッククォートがタイピングしにくいため。

### エフェクトを返すメソッドには型パラメータで表現する

`F[_]` を返すメソッドでは、型クラス制約（`Sync[F]`, `Async[F]` など）を用いてエフェクトの性質を明示してください。
トップレベル以外では `IO` を直接使用せず、抽象化された `F[_]` を用いるようにしてください。

### スコープの長さに応じて説明度が高い名前をつける

スコープが広いほど、変数やメソッドなどの名前はより説明的で意味が明確なものにしてください。逆に、スコープが極めて限定的（例:
for ループ内など）であれば、簡潔な名前を使用してもかまいません。

スコープが広くなると、名前の参照場所と定義場所が離れるため、短い・曖昧な名前では意味が把握しづらくなります。

レキシカルスコープに限らず、以下のような観点から潜在的なスコープの長さを推定し、名前の説明度を調整してください。

| 属性         | 	スコープが長くなる傾向の方向                                  |
|:-----------|:-------------------------------------------------|
| アクセス修飾子    | 	`private` < `protected` < `public` |
| `val` vs `var` | `var` がある方がスコープが長い（状態変化が起き得る）                           |
| `final`	  | ない方がスコープが長い（継承先で使われる可能性がある）                      |
| `sealed`	  | `sealed` がない方がスコープが長い（継承される可能性がある）                      |
| `abstract` | ある方がスコープが長い（継承先クラスで実装する必要がある）                    |

命名例:

| スコープ               | 	命名例                                                   | 	解説                               |
|:-------------------|:-------------------------------------------------------|:----------------------------------|
| ローカル変数（for文内）      | 	`i`, `result`                                         | 	数行以内で完結する用途なら簡潔に                 |
| メソッド内で再利用されるローカル変数 | 	`userName`, `isRetryEnabled`	                         | 意味を明確に                            |
| private フィールド      | 	`lastLoginTime`                                      | 	クラス全体で使われるため説明的に                 |
| public メンバー・クラス名  | `UserDisplayName`, `IsAdministrator`, `OrderProcessor` | 外部に公開されるインターフェースや型として、読みやすく明確な名前に |

※ `i` は許容されうるが、必要に応じてもっと説明的な名前をつけること。

悪い例:

```scala
private var x: Int = 0 // 何の数値か分からない
```

良い例:

```scala
private var retryCount: Int = 0
```

備考:

この指針は変数・フィールド・プロパティ・メソッド・クラス名などすべてに適用されます。**「外に見せるものほど自己説明的であるべき」
**
という原則を忘れないでください。

### ペアになるものはペアになるような名前をつける

ペアになる識別子はペアと認識できるような名前をつけてください。

例:
1. `first` と `second`
2. `dest` と `src`
3. `prev` と `next`
4. `x` と `y`、`a` と `b`
    * スコープが狭い場合に限る
5. `lhs` と `rhs`

### `temp` や `tmp` を使わない

* 一時的であること: `temporary` をつける
* 温度: `temparture` をつける
* テンプレート: `template` をつける
* 値を破棄する: `_` に代入する
* スワップ代入する: `(a, b) = (b, a)` パターンを使う
    * `a`, `b` は適宜名前を変えること

### `Utility` またはそれに類する名前をクラス名に入れない

以下の部分文字列は、*神クラス* を招きやすいため、クラス名の一部として利用しないでください。

* `Utility`
* `Util`

### 否定形のメンバー命名について

* `isDisabled` のような否定形の命名は、一般的に可読性が落ちるため避け、前向きな命名（例: `isEnabled`）を推奨します。
* ただし、肯定形メンバーのみの場合、両方用意すると冗長になるため否定形を追加しないことは許容します。
* 否定形メンバーが存在しない場合でも、`if (!x)` のような否定条件は特別に許容し、読みやすさを優先します。

## 命名以外の構文的な規則

### 型推論を活用する

Scala の型推論を活用し、冗長な型注釈を避けます。ただし、public な API や複雑な型については明示的な型注釈を付けてください。

### Fewer braces (optional braces) は使用しない

Scala 3 の Fewer braces (optional braces) 構文は使用せず、明示的なブレースを使用してください。

理由: 一貫性と可読性のため。

### cypherクエリは neotypes の文字列補間を用いる

neotypes の `c""` 文字列補間を使用してクエリを記述してください。

例:

```scala
val handle = "Taro"
c"CREATE (:Person{name: $handle, age: 20})"
```

## 意味論的な規則

### ユーザー定義演算子は常識的な振る舞いをさせる

ユーザー定義演算子を定義するときは、「常識的」かつ「行儀が良い」な振る舞いをさせるようにしましょう。

以下は、判断の基準を示したケースです:

#### 算術シフト・論理シフト以外の振る舞いを見せるシフト演算子を定義しない

C++ の iostream の過ちを、我々は二度と繰り返すべきではありません。

参考: <https://ufcpp.net/study/csharp/oop/generic-math-operators/>

#### 加減算は、原則として同じ単位量に基づく型のインスタンスの間でのみ行う

メートル同士の足し算は良いが、メートルとセンチメートルを足したときに結果がどうなるか議論の余地があるため、一旦禁止する。

#### 乗除算の結果の型は、次元ベクトルの和として自然に合成された複合単位を返す

例えば、キログラムにメートル毎秒毎秒を乗算した時、その結果を表す型の指数ベクトルは `{ mass: 1, length: 1, second: -2 }` でなければならない。 \
参考: これはニュートンの定義に当たる。

#### 乗算の右オペランドにプリミティブを使用する場合、その意味論はスカラー倍にする

`Meter.operator*(int) -> Meter` （スカラー倍で意味が明確）

#### 除算の左オペランドと右オペランドが同じ次元ベクトルの単位の場合、その戻り値は比率にする

`Meter.operator/(Meter) -> double` （比率計算で意味が明確）

#### 複数通りの解釈を生むユーザー定義演算子を避ける

`TimeSpan.operator+(int) -> TimeSpan` のように、演算子のシグネチャや名前から動作の意図が明確にわからないユーザー定義演算子は定義しないでください。

推奨される代替手段

1. 明示的なメソッドを定義し、動作が一目でわかる名前を付ける。  
   例: `TimeSpan.AddMinutes(int) -> TimeSpan`
2. 引数の型を具体化し、意味を明確にする。  
   例: `TimeSpan.operator+(Minute) -> TimeSpan`

### 等価性とハッシュコードは一貫した振る舞いを見せる

値型や参照型で等価性を定義する場合、==演算子、`Equals` メソッド、 `GetHashCode` メソッドの意味論を必ず一致させます。`record`/`record struct`は自動的にこれを満たすため積極的に利用してください。参照型で意味的等価性を定義する場合、参照同一性と混同しないよう注意します。

### 型変換関数は禁止

`implicit` / `explicit` 演算子はアップキャストと字面上で区別がつかないため禁止します。

インターフェースを用いるか、明示的なメソッドを用いるようにしてください。

### リスコフの置換原則を破らない

リスコフの置換原則を破ることを禁止します。

### is-a 関係が成立する場合のみ継承を使う

is-a 関係が成立する場合のみ継承を使用してください。

### has-a 関係で継承を用いない

has-a 関係が成立するときに継承を用いないでください。

代わりに、"composition over inheritance" 原則に従ってフィールドなどで has-a 関係を表現するようにしてください。

### 外部からの値について検証なしに仮定を置かない

外部からの値については、全く信頼できないものです。常に性悪説を採用し、想定外・不正・欠損・過不足が生じるものとして明示的な検証を行います。勝手な仮定を置かないようにしてください。

これにはデータベースから null が返ってこないこと、HTTP リクエストが特定の形式に従っていること、外部サービスからの取得結果が特定の規則に従っていることなどがありますが、それに限りません。

### リソース管理には cats.effect.Resource を使用する

リソース管理を伴う処理には `cats.effect.Resource` を使用してください。`Resource` は取得と解放を安全に管理し、例外発生時も確実にリソースを解放します。

```scala
val driverResource: Resource[F, AsyncDriver[F]] =
  GraphDatabase.asyncDriver[F](uri, authToken)

driverResource.use { driver =>
  // driver を使った処理
}
```

### エフェクトのキャンセル設計

cats-effect の `IO` は自動的にキャンセルをサポートします。長時間実行される処理では `IO.cancelBoundary` を適切に挿入してキャンセルポイントを設けてください。

### 準正常系ケースに例外を使用しない

例外を使用するのは異常系のケースに限定します。

### タプルの使用はスコープを限定し、要素名を説明的にする

タプル (`(Int, String)`) を使用する場合は、以下を守ってください。

- 使うスコープを限定的（メソッド内）にとどめる
- 公開 API には case class を使用する

悪い例:

```scala
def counts: (Int, Int) = (1, 2)
```

良い例:

```scala
case class Counts(rowCount: Int, columnCount: Int)
def counts: Counts = Counts(rowCount = 1, columnCount = 2)
```

### 独自の例外型には `Exception` を末尾に付け、スロー条件を明確にする

独自の例外型を定義する場合は、`Exception` またはそのサブクラスを継承し、型名の末尾に `Exception` を付けてください。

- `InvalidConfigurationException`
- `DataAccessException`

ただし、エフェクトを使用している場合は例外よりも `Either` や `F.raiseError` を優先してください。

### Option を積極的に使用する

`null` の代わりに `Option` を使用してください。Java ライブラリとの相互運用時は `Option.apply` で `null` を `None` に変換してください。

```scala
val maybeValue: Option[String] = Option(javaMethod()) // null を None に変換
```

### 値オブジェクトは case class または opaque type にする

- 単純なラッパー型には opaque type を使用してください
- 複数のフィールドを持つ値オブジェクトには case class を使用してください

```scala
// opaque type の例
opaque type UserId = UUID
object UserId {
  def apply(id: UUID): UserId = id
  extension (id: UserId) def raw: UUID = id
}

// case class の例
final case class User(id: UserId, name: String)
```

### `val` を使う

イミュータブルなオブジェクトを実現するため、`var` の代わりに `val` を使用してください。`var` が必要な場合は、その理由をコメントで説明してください。

### case class のフィールドは不変にする

case class のフィールドには `var` を使用しないでください。更新が必要な場合は `copy` メソッドを使用してください。

## コレクション

### 不変コレクションを優先する

Scala の不変コレクション（`List`, `Vector`, `Set`, `Map` など）を優先して使用してください。可変コレクションが必要な場合は `scala.collection.mutable` パッケージを明示的にインポートしてください。

### `Array` よりも `Vector` または `List`

配列は可変であるため、不変の `Vector` または `List` を優先してください。パフォーマンスが重要な場合のみ `Array` を使用してください。

### 具体的な型よりも抽象的な型

メソッドの引数には具体的なコレクション型ではなく、`Seq`, `Iterable`, `IterableOnce` などの抽象的な型を使用してください。

## 外部入力

### 許容できない外部入力は早期に例外を投げる

許容できない外部入力は、なるべく早い段階で例外（ArgumentException, FormatException, InvalidOperationException等）をスローし、バグや攻撃の連鎖を防いでください。

### ログと監査証跡

外部入力によるエラー・例外発生時は、最低限エラー内容と入力値の概要をログに記録し、監査・トラブルシュートできるようにしてください。ただし個人情報等の扱いには十分注意を払ってください。

### 外部入力を表示するときはフレームワークが提供する機構でエスケープする

外部入力をWeb画面やXML等に出力する際は、XSS/XXE/CSRFなどのセキュリティリスクを考慮し、フレームワーク標準のエスケープ・検証機構を使ってください。

### cypherクエリを文字列結合で組み立てないこと

Cypherクエリを文字列結合で組み立てることを禁止します。

理由: SQL インジェクションと同じ原理で、 Cypher-Injection になります。

改善方法: neotypes の文字列補間 (`c""`) を使用してください。パラメータは自動的にエスケープされます。

例:
```scala
val handle = user.preferredHandle
val id = user.getIdentifier.raw.toString
c"CREATE (n:Person { handle: $handle, id: $id })".execute.void(driver)
```

## 関数型プログラミング

### for 内包表記を適切に使用する

複数のモナディック操作を連鎖させる場合は for 内包表記を使用してください。

```scala
for {
  user <- findUser(id)
  profile <- loadProfile(user)
  _ <- updateLastLogin(user)
} yield profile
```

### 高階関数のラムダ内で副作用を起こさない

`map`, `filter`, `flatMap` などの高階関数に渡すラムダ内で副作用を起こす操作を禁止します。

理由: デバッグが困難になるため。

修正方法: 副作用が必要な場合は `foreach` または cats-effect の `traverse` を使用してください。

### メソッドチェーンは1回につき1行使う

1行に押し込められていると横に伸びてしまうため、メソッドチェーン1回の呼び出しにつき1行を使用してください。

### 遅延評価を意識する

`LazyList` やイテレータを使用している場合、`toList` や `toVector` で具体化するタイミングに注意してください。無限シーケンスに対して呼び出すとメモリ枯渇につながります。

## ドキュメンテーション

### ScalaDoc は必要なとき以外書かない

ScalaDoc は腐りやすいです。原則「ドキュメントよりも命名、命名よりもシグネチャ」に反するため、挙動を特に説明したいとき以外は原則書かないようにしてください。

「挙動を特に説明したいとき」とは、シグネチャでも命名でも説明できない文脈や事項を注記し、その内容を IDE のツールチップで表示したいときを指します。

### コードと異なるファイルに置かれるドキュメントには、高次のドキュメントのみ置く

コードと異なるファイルに置かれるドキュメントについては、高次のドキュメントのみ置くようにしてください。

「高次のドキュメント」とは、以下のような個々のファイルをまたぐ大きいスコープに対するドキュメントです。

* ARCHITECTURE.md (DAPE の設計の解説)
* CODING_GUIDELINE.md (DAPE のコードを統制するガイドライン)
* CONTRIBUTING.md (DAPE に貢献する方法の紹介)
* FAQ.md (DAPE のよくある質問)
* LICENSE.md (DAPE の利用が許可される範囲)
* README.md (DAPE の紹介、インストール方法、……)

## 機密情報

### トークンをハードコードしない

各種サービスの認証情報はコード上に直接埋め込まないようにしましょう。

代わりに、`.env` や `config.json` などファイルパスを環境変数やコマンドラインスイッチから指定する方法を使用します。

### コマンドライン引数や環境変数から認証情報を直接与えない

コマンドライン引数や環境変数から認証情報を与えるような設計を行わないようにしてください。

Linuxではどちらもprocfsから読み取り可能なため、隠れていると思っていても実際には隠れていません。

## テスト

### どのように振る舞うことが期待されているのかテスト名で明確にする

どのように振る舞うことが期待されているのかテスト名で明確にしてください。

一覧で表示したときに視認性が向上します。

### Arrange-Act-Assert パターンを採用する

テストコードには Arrange-Act-Assert パターンを採用し、初期化→アクション→結果の確認という基本形に従ってください。

参考: <https://xp123.com/3a-arrange-act-assert/>

## 用語の定義

### "Shared Kernel" という用語は用いない

"Shared Kernel" という単語は意味が不明瞭なため、排除します。

代わりに、すべてのモジュールに共通する基礎として *Base レイヤー* という単語を用います。
